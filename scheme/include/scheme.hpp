#pragma once

#include "definitions.h"

namespace DCPE
{
	using namespace std;

	/**
	 * @brief an implementation of the DCPE scheme
	 *
	 */
	class Scheme
	{
		private:
		const number beta;

		/**
		 * @brief The max value of \f$ s \f$ part of the key
		 *
		 * The rationale here is that \f$ s \f$ participates in the following two places in the scheme.
		 *
		 * 1. \f$ \frac{s \beta}{4} \f$ with \f$ \beta \f$ being a 32-bit number.
		 * The result of this needs to fit in 64 bits in the worst case, so \f$ s \f$ is 32 bits max.
		 *
		 * 2. \f$ s m + \lambda_m \f$ with \f$ m \f$ being a vector of floats, 32-bit numbers.
		 * By the same logic, \f$ s \f$ is 32 bits max.
		 *
		 * Thus, the max value of \f$ s \f$ is the largest 32 bit uint.
		 *
		 */
		const number max_s = UINT32_MAX;

		/**
		 * @brief a helper that computes \f$ \lambda_m \f$ value
		 *
		 * @param key a scheme key
		 * @param nonce a nonce generated during encryption
		 * @param dimensions the number of dimensions of the message/ciphertext
		 * @return vector<VALUE_T> the \f$ \lambda_m \f$ intermediate value
		 */
		vector<VALUE_T> compute_lambda_m(key& key, pair<number, number>& nonce, size_t dimensions);

		public:
		/**
		 * @brief Construct a new Scheme object
		 *
		 * @param beta the approximation paramter \f$ \beta \f$
		 */
		Scheme(number beta);

		/**
		 * @brief generate a fresh key for the scheme
		 *
		 * @return key a pair of PRF key and secret \f$ s \f$ from \f$ \mathcal{S} \f$
		 */
		key keygen(bytes hash_key = bytes(), number s = -1);

		/**
		 * @brief encrypts the vector under given key
		 *
		 * @param key a scheme key generated by keygen
		 * @param message a user-supplied vector to encrypt (pointer to start)
		 * @param dimensions the number of dimensions of the vector
		 * @param ciphertext the encrypted vector (has to be allocated of length dimensions)
		 * @return bytes the nonce used in encryption
		 */
		pair<number, number> encrypt(key& key, const VALUE_T* message, size_t dimensions, VALUE_T* ciphertext);

		/**
		 * @brief decrypts the encrypted vector under given key
		 *
		 * @param key a scheme key generated by keygen
		 * @param ciphertext the encrypted vector
		 * @param dimensions the number of dimensions of the vector
		 * @param nonce the nonce used in encryption
		 * @param message the original vector (has to be allocated of length dimensions)
		 */
		void decrypt(key& key, const VALUE_T* ciphertext, size_t dimensions, pair<number, number>& nonce, VALUE_T* message);
	};
}
