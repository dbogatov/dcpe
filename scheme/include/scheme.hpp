#pragma once

#include "definitions.h"

namespace DCPE
{
	/**
	 * @brief an implementation of the DCPE scheme
	 *
	 */
	template <typename VALUE_T>
	class Scheme
	{
		private:
		const VALUE_T beta;

		/**
		 * @brief The max value of \f$ s \f$ part of the key
		 *
		 * It needs to be high enough to enable protper security and low enough to account for rounding errors.
		 *
		 * In particular, \f$ s \f$ is used in \f$ \frac{s \cdot \beta}{4} \f$, and this value should be rounded as least as possible.
		 *
		 * For now we put an empirical guess.
		 *
		 */
		const VALUE_T max_s = 1000.0;

		/**
		 * @brief a helper that computes \f$ \lambda_m \f$ value
		 *
		 * @param key a scheme key
		 * @param nonce a nonce generated during encryption
		 * @param dimensions the number of dimensions of the message/ciphertext
		 * @return vector<VALUE_T> the \f$ \lambda_m \f$ intermediate value
		 */
		std::vector<VALUE_T> compute_lambda_m(key& key, std::pair<ull, ull>& nonce, int dimensions);

		public:
		/**
		 * @brief Construct a new Scheme object
		 *
		 * @param beta the approximation paramter \f$ \beta \f$
		 */
		Scheme(VALUE_T beta);

		/**
		 * @brief generate a fresh key for the scheme
		 *
		 * @return keys that can be used for encryption
		 */
		key keygen();

		/**
		 * @brief encrypts the vector under given key
		 *
		 * @param key a scheme key generated by keygen
		 * @param message a user-supplied vector to encrypt (pointer to start)
		 * @param dimensions the number of dimensions of the vector
		 * @param ciphertext the encrypted vector (has to be allocated of length dimensions)
		 * @return bytes the nonce used in encryption
		 */
		std::pair<ull, ull> encrypt(key& key, const VALUE_T* message, int dimensions, VALUE_T* ciphertext);

		/**
		 * @brief decrypts the encrypted vector under given key
		 *
		 * @param key a scheme key generated by keygen
		 * @param ciphertext the encrypted vector
		 * @param dimensions the number of dimensions of the vector
		 * @param nonce the nonce used in encryption
		 * @param message the original vector (has to be allocated of length dimensions)
		 */
		void decrypt(key& key, const VALUE_T* ciphertext, int dimensions, std::pair<ull, ull>& nonce, VALUE_T* message);
	};
}
